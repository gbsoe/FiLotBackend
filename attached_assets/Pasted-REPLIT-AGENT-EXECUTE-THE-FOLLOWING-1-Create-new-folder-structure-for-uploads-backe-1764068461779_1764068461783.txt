REPLIT AGENT — EXECUTE THE FOLLOWING**

## **1. Create new folder structure for uploads**

```
backend/src/storage/
backend/src/routes/documentsRoutes.ts
backend/src/controllers/documentsController.ts
backend/src/services/r2Storage.ts
```

---

## **2. Install required dependencies**

```
npm install multer @aws-sdk/client-s3 @aws-sdk/s3-request-presigner mime-types
```

---

## **3. Create R2 Storage Service (`r2Storage.ts`)**

**File:** `backend/src/services/r2Storage.ts`

```ts
import {
  S3Client,
  PutObjectCommand,
  DeleteObjectCommand,
} from "@aws-sdk/client-s3";
import { getSignedUrl } from "@aws-sdk/s3-request-presigner";

const client = new S3Client({
  region: "auto",
  endpoint: process.env.CF_R2_ENDPOINT,
  credentials: {
    accessKeyId: process.env.CF_R2_ACCESS_KEY_ID!,
    secretAccessKey: process.env.CF_R2_SECRET_ACCESS_KEY!,
  },
});

const BUCKET = process.env.CF_R2_BUCKET_NAME!;

export const uploadToR2 = async (key: string, buffer: Buffer, contentType: string) => {
  const command = new PutObjectCommand({
    Bucket: BUCKET,
    Key: key,
    Body: buffer,
    ContentType: contentType,
  });

  await client.send(command);

  return `https://${process.env.CF_ACCOUNT_ID}.r2.cloudflarestorage.com/${BUCKET}/${key}`;
};

export const deleteFromR2 = async (key: string) => {
  const command = new DeleteObjectCommand({
    Bucket: BUCKET,
    Key: key,
  });

  await client.send(command);
};
```

---

## **4. Create Upload Controller (`documentsController.ts`)**

**File:** `backend/src/controllers/documentsController.ts`

```ts
import { Request, Response } from "express";
import { uploadToR2 } from "../services/r2Storage";
import { db } from "../db";
import { documents } from "../db/schema";
import { authRequired } from "../auth/middleware";
import mime from "mime-types";
import crypto from "crypto";
import { eq } from "drizzle-orm";

export const uploadDocument = async (req: Request, res: Response) => {
  try {
    if (!req.file) return res.status(400).json({ error: "No file uploaded" });

    const userId = req.user!.id;
    const type = req.body.type;

    if (!["KTP", "NPWP"].includes(type)) {
      return res.status(400).json({ error: "Invalid document type" });
    }

    const extension = mime.extension(req.file.mimetype) || "bin";
    const key = `${userId}/${type}_${crypto.randomUUID()}.${extension}`;

    const url = await uploadToR2(key, req.file.buffer, req.file.mimetype);

    const doc = await db
      .insert(documents)
      .values({
        userId,
        type,
        fileUrl: url,
        status: "uploaded",
        createdAt: new Date(),
      })
      .returning();

    return res.json({
      success: true,
      fileUrl: url,
      document: doc[0],
    });
  } catch (error) {
    console.error("Upload error:", error);
    return res.status(500).json({ error: "Upload failed" });
  }
};
```

---

## **5. Create Documents Routes (`documentsRoutes.ts`)**

**File:** `backend/src/routes/documentsRoutes.ts`

```ts
import express from "express";
import multer from "multer";
import { uploadDocument } from "../controllers/documentsController";
import { authRequired } from "../auth/middleware";

const router = express.Router();
const upload = multer({ storage: multer.memoryStorage() });

router.post(
  "/upload",
  authRequired,
  upload.single("file"),
  uploadDocument
);

export default router;
```

---

## **6. Register Route in Main Server (`index.ts`)**

Modify in `backend/src/index.ts`:

```ts
import documentsRoutes from "./routes/documentsRoutes";

app.use("/documents", documentsRoutes);
```

---

## **7. Update README**

Add documentation under **Backend → Document Upload** describing:

* Upload endpoint
* Required headers
* Request format
* Example response
* File size limit
* Supported MIME types
* Security considerations
* Integration notes for frontend

---

## **8. Create Documentation File**

**File:** `backend/docs/TRANCHE_4_DOCUMENTS.md`

Content:

```
# Tranche 4 — Document Upload & R2 Integration

Includes:
- R2 S3-compatible storage integration
- Upload endpoint (/documents/upload)
- Automatic URL storage in database
- User-based folder structure
- KTP and NPWP upload support
- Future-ready for BULI2 OCR pipeline

Request:
POST /documents/upload
Headers: Authorization: Bearer <token>
Body (multipart/form-data):
  - type: "KTP" | "NPWP"
  - file: <binary file>

Response:
{
  success: true,
  fileUrl: "https://...r2.cloudflarestorage.com/bucket/user/ktp_xxx.png",
  document: { ... }
}

Next: Tranche 5 = Document Processing Pipeline